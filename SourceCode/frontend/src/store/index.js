import Vue from "vue";
import Vuex from "vuex";
import {db, getScheduleRaces, getScheduleNameAndRacerList} from "../firebase";
import { collection, getDocs, writeBatch, doc, query, onSnapshot } from "firebase/firestore";

Vue.use(Vuex);

export default new Vuex.Store({
  state: {
    // User ID (this eventually needs to be made persistent via session storage)
    userId: "Test1",
    racersId: "QoBZZcESsl3PAx18uiYG",
    scheduleId: "KoLRW4tXu4t0pXgneD73",
    scheduleName: "",

    // Schedule
    racers: [],
    racersMap: new Map(),
    schedule: [],

    //Scorers
    Scorers: {
      schedule: [],
      currentRaceId: null,
      currentRaceRacers: [],
      currentRaceScores: [],
    },
    ScoreBoard:{
      scoreBoard:[]
    },
  },
  mutations: {
    doNothing(){
      console.log("This needs to be cleaned up. Do nothing mutation in store...")
    },
    updateRacers(state, {racersArr, racersMap}){
      state.racers = racersArr;
      state.racersMap = racersMap;
    },
    // Scorers
    updateSchedule(state, { schedule, name, racerList }) {
      state.Scorers.schedule = schedule;
      state.racersId = racerList;
      state.scheduleName = name;
    },
    updateCurrentRace(
      state,
      { currentRaceId, currentRaceRacers, currentRaceScores }
    ) {
      state.Scorers.currentRaceId = currentRaceId;
      state.Scorers.currentRaceRacers = currentRaceRacers;
      state.Scorers.currentRaceScores = currentRaceScores;
    },
    //Score Board
    updateScoreBoard(state, {scoreBoard}){
      state.ScoreBoard.scoreBoard=scoreBoard;
    },
  },
  getters: {},
  actions: {
    async updateAllRacers({commit}, {racersId, newList, removedRacers}){
      // create batch to update racer if already in collection
      // also add racer if not already in db
      const batch = writeBatch(db);
      for(let i = 0; i < newList.length; i++){
          if(newList[i].dbId === undefined){
              // gets autogenerated ref
              let myNewRef = doc(collection(db, "MasterRacers", racersId, "Racers"));
              batch.set(myNewRef, { name: newList[i].name, id: newList[i].id, score: 0 });
          }
          else{
              const myRef = doc(db, "MasterRacers", racersId, "Racers", newList[i].dbId);
              batch.update(myRef, { name: newList[i].name, id: newList[i].id, score: 0 });
          }
      }
      for(let i = 0; i < removedRacers.length; i++){
          if(removedRacers[i].dbId === undefined) continue;

          let myRemRef = doc(db, "MasterRacers", racersId, "Racers", removedRacers[i].dbId);
          batch.delete(myRemRef);
      }
      
      await batch.commit();

      commit("doNothing");
    },
    async getAllRacers({commit}, {racersId}){
      const query = await getDocs(collection(db, "MasterRacers", racersId, "Racers"));
      let allRacers = [];
      let allRacersMap = new Map();
      query.forEach((doc)=> {
          let racer = doc.data();
          allRacersMap.set(doc.id, racer);
          racer.dbId = doc.id;
          allRacers.push(racer);
      });
      commit("updateRacers",{
        racersArr: allRacers,
        racersMap: allRacersMap,
      });
    },
    //Scorers
    async getFullSchedule({commit}, {scheduleId}) {
      let mySchedule = await getScheduleRaces(scheduleId);
      let nameAndRacer = await getScheduleNameAndRacerList(scheduleId);
      commit("updateSchedule", { schedule: mySchedule, name: nameAndRacer.Name, racerList:nameAndRacer.RacerList });
      
    },
    async subscribeToScoreBoard({commit}, {racerListId}){
      // Make sure all racers is up to date
      const myQuery = query(collection(db,"MasterRacers",racerListId,"Racers"));
      let myScoreBoard=[];
      onSnapshot(myQuery,(snapshot) =>
      {
        myScoreBoard= [];
        snapshot.forEach((doc) =>{
          myScoreBoard.push({racerNumber: doc.data().id, racerName: doc.data().name, racerScore: doc.data().score, numberOfRaces: "NA"})
        });
        let sortedScoreBoard = myScoreBoard.sort((a,b) => b.racerScore-a.racerScore);
        commit("updateScoreBoard", { scoreBoard: sortedScoreBoard });
      });
    },
  },
});
