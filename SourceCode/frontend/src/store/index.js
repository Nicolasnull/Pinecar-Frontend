import Vue from "vue";
import Vuex from "vuex";
import {db} from "../firebase";
import { collection, getDocs, writeBatch, doc } from "firebase/firestore";

Vue.use(Vuex);

export default new Vuex.Store({
  state: {
    // User ID (this eventually needs to be made persistent via session storage)
    userId: "Test1",
    racersId: "QoBZZcESsl3PAx18uiYG",
    scheduleId: "KoLRW4tXu4t0pXgneD73",

    // Schedule
    racers: [],
    racersMap: new Map(),
    schedule: [],

    //Scorers
    Scorers: {
      schedule: [],
      currentRaceId: null,
      currentRaceRacers: [],
      currentRaceScores: [],
    },
    ScoreBoard:{
      scoreBoard:[]
    },
  },
  mutations: {
    doNothing(){
      console.log("This needs to be cleaned up. Do nothing mutation in store...")
    },
    updateRacers(state, {racersArr, racersMap}){
      state.racers = racersArr;
      state.racersMap = racersMap;
    },
    // Scorers
    updateSchedule(state, { schedule }) {
      state.Scorers.schedule = schedule;
    },
    updateCurrentRace(
      state,
      { currentRaceId, currentRaceRacers, currentRaceScores }
    ) {
      state.Scorers.currentRaceId = currentRaceId;
      state.Scorers.currentRaceRacers = currentRaceRacers;
      state.Scorers.currentRaceScores = currentRaceScores;
    },
    //Score Board
    updateScoreBoard(state, {scoreBoard}){
      state.ScoreBoard.scoreBoard=scoreBoard;
    },
  },
  getters: {},
  actions: {
    async updateAllRacers({commit}, {racersId, newList, removedRacers}){
      // create batch to update racer if already in collection
      // also add racer if not already in db
      const batch = writeBatch(db);
      for(let i = 0; i < newList.length; i++){
          if(newList[i].dbId === undefined){
              // gets autogenerated ref
              let myNewRef = doc(collection(db, "MasterRacers", racersId, "Racers"));
              batch.set(myNewRef, { name: newList[i].name, id: newList[i].id, score: newList[i].score });
          }
          else{
              const myRef = doc(db, "MasterRacers", racersId, "Racers", newList[i].dbId);
              batch.update(myRef, { name: newList[i].name, id: newList[i].id, score: newList[i].score });
          }
      }
      for(let i = 0; i < removedRacers.length; i++){
          if(removedRacers[i].dbId === undefined) continue;

          let myRemRef = doc(db, "MasterRacers", racersId, "Racers", removedRacers[i].dbId);
          batch.delete(myRemRef);
      }
      
      await batch.commit();

      commit("doNothing");
    },
    async getAllRacers({commit}, {racersId}){
      const query = await getDocs(collection(db, "MasterRacers", racersId, "Racers"));
      let allRacers = [];
      let allRacersMap = new Map();
      query.forEach((doc)=> {
          let racer = doc.data();
          allRacersMap.set(doc.id, racer);
          racer.dbId = doc.id;
          allRacers.push(racer);
      });
      commit("updateRacers",{
        racersArr: allRacers,
        racersMap: allRacersMap,
      });
    },
    //Scorers
    async getFullSchedule() {
      let mySchedule = [
        { raceId: 1, racers: [12, 2, 3, 42], scores: [0, 0, 0, 0] },
        { raceId: 2, racers: [2, 3, 4, 1], scores: [0, 0, 0, 0] },
        { raceId: 3, racers: [3, 4, 1, 2], scores: [0, 0, 0, 0] },
        { raceId: 4, racers: [4, 1, 2, 3], scores: [0, 0, 0, 0] },
      ];
      this.commit("updateSchedule", { schedule: mySchedule });
      this.commit("updateCurrentRace", {
        currentRaceId: 1,
        racers: [1, 2, 3, 4],
        scores: [0, 0, 0, 0],
      });
    },
    async getScoreBoard(){
      let myScoreBoard = [
        {racerNumber: 3, racerName: "Julia N.", racerScore:12, numberOfRaces: 3},
        {racerNumber: 2, racerName: "Nate N.", racerScore:9, numberOfRaces: 3},
        {racerNumber: 4, racerName: "Kate N.", racerScore:6, numberOfRaces: 3},
        {racerNumber: 1, racerName: "Nic N.", racerScore:3, numberOfRaces: 3},
      ];
      this.commit("updateScoreBoard", { scoreBoard: myScoreBoard });
    },
  },
});
